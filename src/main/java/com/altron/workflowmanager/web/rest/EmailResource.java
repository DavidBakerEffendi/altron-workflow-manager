package com.altron.workflowmanager.web.rest;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.validation.Valid;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.altron.workflowmanager.domain.Attachments;
import com.altron.workflowmanager.domain.Email;
import com.altron.workflowmanager.domain.User;
import com.altron.workflowmanager.repository.AttachmentsRepository;
import com.altron.workflowmanager.repository.EmailRepository;
import com.altron.workflowmanager.service.MailService;
import com.altron.workflowmanager.service.UserService;
import com.altron.workflowmanager.web.rest.errors.BadRequestAlertException;
import com.altron.workflowmanager.web.rest.errors.InternalServerErrorException;
import com.altron.workflowmanager.web.rest.util.HeaderUtil;
import com.codahale.metrics.annotation.Timed;

import io.github.jhipster.web.util.ResponseUtil;

/**
 * REST controller for managing Email.
 */
@RestController
@RequestMapping("/api")
public class EmailResource {

	private final Logger log = LoggerFactory.getLogger(EmailResource.class);

	private static final String ENTITY_NAME = "email";

	private final EmailRepository emailRepository;
	private final MailService mailService;
	private final UserService userService;
	private final AttachmentsRepository attachmentsRepository;

	public EmailResource(EmailRepository emailRepository, MailService mailService, UserService userService,
			AttachmentsRepository attachmentsRepository) {
		this.mailService = mailService;
		this.emailRepository = emailRepository;
		this.userService = userService;
		this.attachmentsRepository = attachmentsRepository;
	}

	/**
	 * 
	 * POST getProjectEmail
	 * 
	 * @param email
	 * 
	 * @return {@linkplain HttpStatus.OK} if the filed was successfully saved,
	 *         {@linkplain HttpStatus.INTERNAL_SERVER_ERROR} if otherwise.
	 * 
	 *         This is designed to send a project report/DAC for approval. Obtains
	 *         attachments from DB
	 */
	@PostMapping("/project-email")
	public ResponseEntity<Object> getProjectEmail(@Valid @RequestBody Email email) {
		log.debug("Alert email request received");
		Optional<User> user = userService.getUserWithAuthorities();
		if (!user.isPresent()) {
			return new ResponseEntity<>(new InternalServerErrorException("User could not be found"), null,
					HttpStatus.INTERNAL_SERVER_ERROR);
		}

		List<Attachments> attchs = attachmentsRepository.findAllByEmailID(email.getId());
		Map<String, Object> messages = new HashMap<String, Object>();
		messages.put("message", "saved attatchments");
		messages.put("status", HttpStatus.OK);
		messages.put("ok", true);
		mailService.sendProjectReportEmail(email, attchs);
		return new ResponseEntity<>(messages, null, HttpStatus.OK);
	}

	/**
	 * GET getEmailAttachments
	 * 
	 * @param id
	 * 
	 * @return {@linkplain HttpStatus.OK} if the filed was successfully saved,
	 *         {@linkplain HttpStatus.INTERNAL_SERVER_ERROR} if otherwise.
	 * 
	 */
	@GetMapping("/emails/{id}/attachments")
	public ResponseEntity<List<Attachments>> getEmailAttachments(@PathVariable Long id) {
		log.debug("Request for attachments belonging to email with id: {}", id);
		List<Attachments> attachments = attachmentsRepository.getAttachments(id);
		for (Attachments a : attachments) {
			log.debug("Attachment name: {}", a.getName());
		}
		return new ResponseEntity<>(attachments, null, HttpStatus.OK);
	}

	/**************************************************************************
	 * AUTOGENERATED CODE BELOW
	 *************************************************************************/

	/**
	 * POST /emails : Create a new email.
	 *
	 * @param email
	 *            the email to create
	 * @return the ResponseEntity with status 201 (Created) and with body the new
	 *         email, or with status 400 (Bad Request) if the email has already an
	 *         ID
	 * @throws URISyntaxException
	 *             if the Location URI syntax is incorrect
	 */
	@PostMapping("/emails")
	@Timed
	public ResponseEntity<Email> createEmail(@Valid @RequestBody Email email) throws URISyntaxException {
		log.debug("REST request to save Email : {}", email);
		if (email.getId() != null) {
			throw new BadRequestAlertException("A new email cannot already have an ID", ENTITY_NAME, "idexists");
		}
		Email result = emailRepository.save(email);
		return ResponseEntity.created(new URI("/api/emails/" + result.getId()))
				.headers(HeaderUtil.createEntityCreationAlert(ENTITY_NAME, result.getId().toString())).body(result);
	}

	/**
	 * PUT /emails : Updates an existing email.
	 *
	 * @param email
	 *            the email to update
	 * @return the ResponseEntity with status 200 (OK) and with body the updated
	 *         email, or with status 400 (Bad Request) if the email is not valid, or
	 *         with status 500 (Internal Server Error) if the email couldn't be
	 *         updated
	 * @throws URISyntaxException
	 *             if the Location URI syntax is incorrect
	 */
	@PutMapping("/emails")
	@Timed
	public ResponseEntity<Email> updateEmail(@Valid @RequestBody Email email) throws URISyntaxException {
		log.debug("REST request to update Email : {}", email);
		if (email.getId() == null) {
			throw new BadRequestAlertException("Invalid id", ENTITY_NAME, "idnull");
		}
		Email result = emailRepository.save(email);
		return ResponseEntity.ok().headers(HeaderUtil.createEntityUpdateAlert(ENTITY_NAME, email.getId().toString()))
				.body(result);
	}

	/**
	 * GET /emails : get all the emails.
	 *
	 * @return the ResponseEntity with status 200 (OK) and the list of emails in
	 *         body
	 */
	@GetMapping("/emails")
	@Timed
	public List<Email> getAllEmails() {
		log.debug("REST request to get all Emails");
		return emailRepository.findAll();
	}

	/**
	 * GET /emails/:id : get the "id" email.
	 *
	 * @param id
	 *            the id of the email to retrieve
	 * @return the ResponseEntity with status 200 (OK) and with body the email, or
	 *         with status 404 (Not Found)
	 */
	@GetMapping("/emails/{id}")
	@Timed
	public ResponseEntity<Email> getEmail(@PathVariable Long id) {
		log.debug("REST request to get Email : {}", id);
		Optional<Email> email = emailRepository.findById(id);
		return ResponseUtil.wrapOrNotFound(email);
	}

	/**
	 * DELETE /emails/:id : delete the "id" email.
	 *
	 * @param id
	 *            the id of the email to delete
	 * @return the ResponseEntity with status 200 (OK)
	 */
	@DeleteMapping("/emails/{id}")
	@Timed
	public ResponseEntity<Void> deleteEmail(@PathVariable Long id) {
		log.debug("REST request to delete Email : {}", id);

		emailRepository.deleteById(id);
		return ResponseEntity.ok().headers(HeaderUtil.createEntityDeletionAlert(ENTITY_NAME, id.toString())).build();
	}
}
